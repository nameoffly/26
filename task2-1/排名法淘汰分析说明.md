# 排名法淘汰分析说明文档

## 一、代码目标与背景

### 1.1 研究问题
本代码用于解决 **2026 MCM Problem C** 的第二个问题：对第 3-27 季的《与星共舞》节目，应用**排名法（Rank Method）**进行淘汰决策，并与**百分比法（Percentage Method）**的实际淘汰结果进行对比分析。

### 1.2 两种淘汰方法对比

#### 百分比法（节目实际使用）
- **综合得分** = 评委百分比 + 观众百分比
- 淘汰综合得分最低的 k 名选手

#### 排名法（本研究模拟）
- 对评委百分比排名（1 = 最好）
- 对观众百分比排名（1 = 最好）
- **综合排名** = 评委排名 + 观众排名（和越小越好）
- 淘汰综合排名和最大的 k 名选手

### 1.3 核心研究问题
1. 排名法与百分比法的淘汰结果有多大差异？
2. 当结果不同时，哪种方法更偏向观众意见？

---

## 二、数据来源

### 2.1 输入数据文件

| 文件名 | 路径 | 内容 |
|--------|------|------|
| `2026_MCM_Problem_C_Processed_Data.xlsx` | 项目根目录 | 包含评委百分比、实际淘汰结果 |
| `fan_vote_estimates_entropy_smooth_100.csv` | task2-1 目录 | 估计的观众投票百分比（来自问题一） |

### 2.2 输出数据文件

| 文件名 | 内容 |
|--------|------|
| `rank_vs_percent_elimination_2.csv` | 每周淘汰结果对比详细记录 |

---

## 三、核心算法逻辑

### 3.1 排名规则详解

#### 排名计算方法
使用 `pandas.rank(ascending=False, method='min')`：
- **降序排名**：百分比最高者排名为 1
- **同分处理**：相同百分比的选手获得相同排名（取该组最小名次）
- **名次顺延**：例如两人并列第一（排名都是 1），下一名为第三（排名 3）

**示例：**
```
选手    百分比    排名
A       30%       1
B       30%       1    ← 并列第一
C       25%       3    ← 跳过 2，直接为 3
D       20%       4
```

#### 综合排名计算
```python
综合排名 = 评委排名 + 观众排名
```

**淘汰规则：**
- 综合排名和最大的 k 名选手被淘汰
- 若综合排名相同，则评委排名更差（数字更大）的优先淘汰

### 3.2 核心函数说明

#### `apply_rank_method_one_week()`
**功能：** 对某一周的选手应用排名法，决定淘汰名单

**输入参数：**
- `names`: 选手名单
- `judge_percents`: 评委百分比数组
- `fan_percents`: 观众百分比数组
- `n_eliminate`: 需要淘汰的人数

**处理流程：**
```
1. 计算评委排名（降序，最高百分比=1）
2. 计算观众排名（降序，最高百分比=1）
3. 计算综合排名 = 评委排名 + 观众排名
4. 按综合排名降序排序，同分时评委排名更差的优先
5. 取前 n_eliminate 名选手作为淘汰名单
```

**关键代码：**
```python
# 评委排名：降序，最高百分比=1；同分同排名、下一名顺延
judge_rank = pd.Series(judge_percents).rank(ascending=False, method='min').astype(int).values

# 观众排名：同上
fan_rank = pd.Series(fan_percents).rank(ascending=False, method='min').astype(int).values

# 综合排名
sum_rank = judge_rank + fan_rank

# 按综合和从大到小排，同分时评委排名大的（更差）在前，先淘汰
idx = np.lexsort((-judge_rank, -sum_rank))
eliminated_idx = idx[:n_eliminate]
```

#### `run_rank_method_all_seasons()`
**功能：** 遍历第 3-27 季的所有周，应用排名法并与百分比法对比

**处理流程：**
```
对每一季：
  对每一周：
    1. 获取该周参赛选手、评委百分比
    2. 从估计数据获取观众百分比
    3. 获取百分比法实际淘汰名单
    4. 应用排名法得到淘汰名单
    5. 比较两种方法的淘汰结果是否一致
    6. 记录差异（如果有）
```

**返回值：**
- `DataFrame`: 每周对比结果（包含列：season, week, n_contestants, n_eliminated, percent_eliminated, rank_eliminated, same_result）
- `list`: 差异详情（仅包含结果不同的周）

---

## 四、差异分析方法

### 4.1 分析目标
当排名法和百分比法淘汰结果不同时，判断**哪种方法更偏向观众意见**。

### 4.2 分析逻辑

#### 核心假设
1. **观众投票占比高** = 该选手受观众欢迎
2. **某方法保留了高观众人气的选手** = 该方法更偏向观众

#### 分析指标

定义两类差异选手：
- **仅百分比法淘汰**：在百分比法下被淘汰，但排名法下被保留
- **仅排名法淘汰**：在排名法下被淘汰，但百分比法下被保留

对每类选手，比较其观众投票占比与该周平均值：

| 选手类型 | 观众占比特征 | 说明 | 倾向判断 |
|---------|-------------|------|---------|
| 仅百分比法淘汰 | 高于平均 | 排名法保留了高人气选手 | **排名法更偏观众** |
| 仅排名法淘汰 | 低于平均 | 排名法淘汰了低人气选手 | **排名法更偏观众** |
| 仅百分比法淘汰 | 低于平均 | 百分比法淘汰了低人气选手 | **百分比法更偏观众** |
| 仅排名法淘汰 | 高于平均 | 百分比法保留了高人气选手 | **百分比法更偏观众** |

#### 函数实现：`analyze_which_favors_audience()`

**统计变量：**
```python
rank_eliminated_tend_to_low_fan = 0     # 仅排名法淘汰且观众%低于平均
percent_eliminated_tend_to_high_fan = 0 # 仅百分比法淘汰且观众%高于平均
```

**判断逻辑：**
```python
favor_rank_audience = percent_eliminated_tend_to_high_fan + rank_eliminated_tend_to_low_fan

if favor_rank_audience > favor_percent_audience:
    结论：排名法更偏向观众意见
elif favor_percent_audience > favor_rank_audience:
    结论：百分比法更偏向观众意见
else:
    结论：无明显倾向
```

---

## 五、统计指标说明

### 5.1 主要统计量

| 指标 | 说明 | 计算方法 |
|------|------|---------|
| **总周数** | 有选手参与的所有周数 | 遍历第3-27季所有周 |
| **无人淘汰周数** | n_eliminated = 0 的周数 | 统计 `df[df['n_eliminated'] == 0]` |
| **有人淘汰周数** | n_eliminated > 0 的周数 | 统计 `df[df['n_eliminated'] > 0]` |
| **淘汰结果一致周数** | 两种方法淘汰名单完全相同 | 在有人淘汰的周数中统计 `same_result == True` |
| **淘汰结果不同周数** | 两种方法淘汰名单不同 | 在有人淘汰的周数中统计 `same_result == False` |
| **一致比例** | 结果一致周数占比 | `same_weeks / weeks_with_elimination × 100%` |

### 5.2 重要设计：排除无人淘汰周数

**为什么要排除？**
- 当某周无人淘汰（n_eliminated = 0）时，两种方法都不淘汰任何人
- 这种情况下"一致"是平凡的，不反映两种方法的实质差异
- 将其纳入统计会人为提高"一致比例"

**实现代码：**
```python
df_with_elimination = df[df['n_eliminated'] > 0]  # 只考虑有人淘汰的周数
weeks_with_elimination = len(df_with_elimination)
same_weeks = df_with_elimination['same_result'].sum()
```

---

## 六、使用方法

### 6.1 运行环境要求
```bash
# Python 依赖
pip install pandas numpy openpyxl
```

### 6.2 文件准备
确保以下文件存在：
```
2026_C/
├── 2026_MCM_Problem_C_Processed_Data.xlsx  # 评委数据和实际淘汰
└── task2-1/
    ├── rank_method_elimination.py          # 本代码
    └── fan_vote_estimates_entropy_smooth_100.csv  # 观众估计（来自问题一）
```

### 6.3 运行代码
```bash
cd task2-1
python rank_method_elimination.py
```

### 6.4 输出示例
```
============================================================
问题二：排名法 vs 百分比法 淘汰结果比较（第3-27季）
============================================================
评委数据: D:\...\2026_MCM_Problem_C_Processed_Data.xlsx
观众估计: D:\...\fan_vote_estimates_entropy_smooth_100.csv

总周数（有选手参与）: 249
  其中无人淘汰周数: 13
  其中有人淘汰周数: 236
淘汰结果一致周数: 180
淘汰结果不同周数: 56
一致比例（仅统计有淘汰的周数）: 76.3%

每周对比已保存: rank_vs_percent_elimination_2.csv

淘汰结果不同的部分周（前20个）：
------------------------------------------------------------
  第3季 第2周:
    百分比法淘汰: ['Jerry Rice']
    排名法淘汰:   ['Master P']
    仅百分比法淘汰: ['Jerry Rice']
    仅排名法淘汰:   ['Master P']
  ...
```

---

## 七、结果解读

### 7.1 CSV 输出文件字段说明

`rank_vs_percent_elimination_2.csv` 包含以下字段：

| 字段名 | 说明 | 示例 |
|--------|------|------|
| `season` | 季数 | 3 |
| `week` | 周数 | 2 |
| `n_contestants` | 该周参赛选手数 | 10 |
| `n_eliminated` | 淘汰人数 | 1 |
| `percent_eliminated` | 百分比法淘汰名单（逗号分隔） | "Jerry Rice" |
| `rank_eliminated` | 排名法淘汰名单（逗号分隔） | "Master P" |
| `same_result` | 两种方法结果是否一致 | False |

### 7.2 差异案例分析示例

假设某周差异如下：
```
第15季 第5周:
  百分比法淘汰: ['选手A']
  排名法淘汰:   ['选手B']
  
选手A：评委30%，观众25% → 百分比法总分55%
选手B：评委28%，观众20% → 百分比法总分48%

选手A：评委排名2，观众排名3 → 排名法综合5
选手B：评委排名3，观众排名5 → 排名法综合8
```

**分析：**
- 百分比法淘汰了选手A（总分55%较高但仍被淘汰）
- 排名法淘汰了选手B（综合排名和更大）
- 选手A观众占比（25%）高于选手B（20%）
- 排名法保留了观众人气更高的选手A → **排名法更偏观众**

### 7.3 统计结论的三种可能

1. **排名法更偏观众**
   - 多数差异案例中，排名法保留了高观众人气的选手
   - 或排名法淘汰了低观众人气的选手

2. **百分比法更偏观众**
   - 多数差异案例中，百分比法保留了高观众人气的选手
   - 或百分比法淘汰了低观众人气的选手

3. **无明显倾向**
   - 两种情况出现次数相近
   - 无法判断哪种方法更偏向观众

---

## 八、技术细节

### 8.1 排序中的同分处理

**lexsort 双重排序：**
```python
idx = np.lexsort((-judge_rank, -sum_rank))
```

- **第一关键字**：`-sum_rank`（综合排名降序）
- **第二关键字**：`-judge_rank`（评委排名降序）

**效果：**
- 优先按综合排名排序
- 综合排名相同时，评委排名更差（数字更大）的排在前面（优先淘汰）

### 8.2 编码处理

```python
if sys.stdout.encoding != 'utf-8':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
    except Exception:
        pass
```

确保中文选手名字能正确显示在终端。

### 8.3 数据匹配策略

**观众百分比获取：**
```python
week_fan = fan_season[fan_season['week'] == week]
name_to_fan = dict(zip(week_fan['celebrity_name'], week_fan['fan_vote_percent']))
fan_percents = np.array([name_to_fan.get(n, 0.0) for n in names])
```

- 建立选手名到观众百分比的字典映射
- 使用 `get(n, 0.0)` 确保找不到时默认为 0%

---

## 九、注意事项与局限性

### 9.1 数据质量依赖
- 观众投票百分比来自问题一的**估计结果**（`fan_vote_estimates_entropy_smooth_100.csv`）
- 估计误差会影响排名法的淘汰结果
- 不同的观众估计方法（如改变平滑参数）会导致不同的对比结果

### 9.2 排名法的理论假设
- 假设排名的重要性是**线性可加的**（评委排名 + 观众排名）
- 实际中，排名差异的"重要性"可能是非线性的

### 9.3 同分处理的影响
- 使用 `method='min'` 的排名策略（并列取最小名次）
- 不同的同分处理方式可能影响最终淘汰结果

### 9.4 统计样本量
- 仅分析第 3-27 季（25 季）
- 每季平均约 10 周
- 总样本约 250 周（排除无人淘汰周后约 236 周）

---

## 十、扩展与改进方向

### 10.1 敏感性分析
- 改变排名规则（如使用 `method='average'` 而非 `method='min'`）
- 改变同分时的优先级（如优先淘汰观众排名差的）
- 使用不同平滑参数的观众估计结果

### 10.2 加权排名法
```python
综合排名 = α × 评委排名 + (1-α) × 观众排名
```
分析不同权重 α 下的淘汰结果。

### 10.3 可视化分析
- 绘制一致比例随季数变化的趋势图
- 差异周的选手百分比分布散点图
- 评委排名 vs 观众排名的二维热力图

### 10.4 统计检验
- 使用卡方检验判断两种方法差异的显著性
- Bootstrap 重采样估计一致比例的置信区间

---

## 十一、引用与参考

### 11.1 数据来源
- 原始数据：`2026_MCM_Problem_C_Processed_Data.xlsx`
- 观众估计：`task1-1/fan_vote_certainty_analysis.py` 生成的 `fan_vote_estimates_entropy_smooth_100.csv`

### 11.2 相关文件
- **问题一代码**：`task1-1/fan_vote_certainty_analysis.py`（观众投票估计）
- **问题一说明**：`task1-1/观众投票估计模型使用说明.md`

### 11.3 问题背景
参见 **2026 MCM Problem C** 题目描述和 Appendix 中的排名法规则说明。

---

## 联系与反馈

如有疑问或改进建议，请联系项目维护者。

---

**最后更新时间：** 2026年1月31日
