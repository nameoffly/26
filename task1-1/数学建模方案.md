# 观众投票估计数学建模与解法方案

## 一、问题描述

### 1.1 研究背景

Dancing with the Stars (DWTS) 是一档舞蹈竞技真人秀节目，每周由评委打分和观众投票共同决定选手去留。观众投票数据是节目的商业机密，本研究旨在通过数学建模方法，基于公开的评委打分和淘汰结果，反向估算每位选手的观众投票情况。

### 1.2 研究对象

- **数据范围**: 第3-27季 (使用百分比打分方法)
- **目标变量**: 每位选手在其参赛各周的观众投票百分比 $v_{i,t}$
- **已知数据**: 评委打分百分比 $j_{i,t}$、每周淘汰情况、决赛排名

### 1.3 计分规则

根据DWTS官方规则，第3-27季使用**百分比方法**:

1. **评委百分比**：选手的评委总分 / 本周所有选手的评委总分之和
2. **观众百分比**：选手的观众票数 / 本周所有观众票数之和  
3. **总百分比** = 评委百分比 + 观众百分比
4. **淘汰规则**：总百分比最低的选手被淘汰（决赛周则用于排名1st, 2nd, 3rd...）

---

## 二、数学模型

### 2.1 决策变量

对于第 $s$ 季第 $t$ 周的第 $i$ 位选手，定义：

| 符号 | 含义 | 状态 |
|------|------|------|
| $v_{s,i,t}$ | 观众投票百分比 | 待估计（决策变量） |
| $j_{s,i,t}$ | 评委打分百分比 | 已知（从数据提取） |
| $T_{s,i,t}$ | 总百分比 | 计算值：$T_{s,i,t} = j_{s,i,t} + v_{s,i,t}$ |

### 2.2 优化目标函数

本模型采用**最大熵原理**和**时间平滑性**的联合优化框架：

$$
\max \quad \sum_{s,t} H_{s,t}(v) - \lambda \sum_{s,t,i} (v_{s,i,t} - v_{s,i,t-1})^2
$$

其中：
- $H_{s,t}(v) = -\sum_{i} v_{s,i,t} \log(v_{s,i,t})$ 是第 $t$ 周的**熵**
- $\lambda \geq 0$ 是**平滑性权重参数**

等价于**最小化问题**：

$$
\min \quad \sum_{s,t} \sum_{i} v_{s,i,t} \log(v_{s,i,t}) + \lambda \sum_{s,t,i} (v_{s,i,t} - v_{s,i,t-1})^2
$$

**目标函数的两个组成部分**：

1. **负熵项** $\sum v_{i,t} \log(v_{i,t})$
   - 作用：促使投票分布尽可能均匀
   - 理由：在缺乏先验信息时，最大熵分布是最合理的估计
   - 避免极端解：防止某些选手获得过高或过低的观众投票份额

2. **平滑性惩罚项** $\lambda \sum (v_{i,t} - v_{i,t-1})^2$
   - 作用：确保同一选手的投票份额在相邻周之间变化平缓
   - 理由：选手的人气不会突然剧烈变化
   - 联合优化：跨越整个赛季的所有周，而非逐周独立求解

### 2.3 约束条件

#### (1) 归一化约束（等式约束）

每周所有选手的观众投票百分比之和为1：

$$
\sum_{i=1}^{n_t} v_{s,i,t} = 1, \quad \forall s, t
$$

其中 $n_t$ 是第 $t$ 周的选手数量。

#### (2) 非负性约束（边界约束）

$$
v_{s,i,t} \geq 0, \quad \forall s, i, t
$$

在实现中，为避免 $\log(0)$ 的数值问题，实际设置下界为小正数：$v_{s,i,t} \geq 10^{-10}$

#### (3) 非决赛周的淘汰约束（不等式约束）

对于第 $t$ 周被淘汰的选手 $e$ 和幸存者 $s$，淘汰者的总百分比必须低于幸存者：

$$
T_{s,e,t} < T_{s,s,t}
$$

展开并转换为观众投票的约束形式：

$$
\begin{align}
j_{s,e,t} + v_{s,e,t} &< j_{s,s,t} + v_{s,s,t} + \varepsilon \\
v_{s,s,t} - v_{s,e,t} &> j_{s,e,t} - j_{s,s,t} + \varepsilon
\end{align}
$$

其中 $\varepsilon > 0$ 是严格不等式的小量（本模型采用 $\varepsilon = 10^{-9}$）。

**说明**：
- 若不使用 $\varepsilon$，直接使用 $\geq$ 约束，优化器可能给出边界解（总分恰好相等）
- $\varepsilon = 10^{-9}$ 足够小，既保证严格不等式，又不会过度放松约束
- 过大的 $\varepsilon$（如0.01）会导致不合理的解空间

#### (4) 决赛周的排名约束（不等式约束）

**决赛周识别规则**：
- H列（results）中标记为"1st Place"、"2nd Place"等
- 该周无选手被淘汰

对于决赛周，排名第 $k$ 的选手总分必须高于排名第 $k+1$ 的选手：

$$
T_{rank\_k} > T_{rank\_k+1} + \varepsilon
$$

展开并转换：

$$
\begin{align}
j_{rank\_k} + v_{rank\_k} &> j_{rank\_k+1} + v_{rank\_k+1} + \varepsilon \\
v_{rank\_k} - v_{rank\_k+1} &> (j_{rank\_k+1} - j_{rank\_k}) + \varepsilon
\end{align}
$$

---

## 三、求解方法

### 3.1 季度联合优化策略

**核心思想**：对每个季度的所有周进行**联合优化**，而非逐周独立求解。

**优势**：
1. 时间平滑性约束需要跨周信息，只有联合优化才能实现
2. 避免人气剧烈抖动，保证估计结果的连续性和合理性
3. 全局视角下的最优解比局部最优解更稳定

### 3.2 优化算法

采用 **序列二次规划（SLSQP, Sequential Least Squares Programming）** 方法：

```python
from scipy.optimize import minimize

# 构造目标函数
def objective(v):
    # 负熵项
    neg_entropy = sum(v[i,t] * log(v[i,t]) for t, i)
    
    # 平滑性项
    smoothness = lambda_smooth * sum(
        (v[i,t] - v[i,t-1])**2 
        for i, t in range(2, T+1)
    )
    
    return neg_entropy + smoothness

# 构造约束
constraints = [
    # 归一化约束
    {'type': 'eq', 'fun': lambda v: sum(v[i,t] for i) - 1},
    
    # 淘汰约束
    {'type': 'ineq', 'fun': lambda v: v[s] - v[e] - diff},
    
    # 决赛排名约束
    {'type': 'ineq', 'fun': lambda v: v[rank_k] - v[rank_k+1] - diff}
]

# 求解
result = minimize(
    objective, 
    v0,                      # 初始值（均匀分布）
    method='SLSQP',          # 序列二次规划
    jac=objective_grad,      # 提供梯度加速收敛
    bounds=[(1e-10, 1.0)],   # 变量界
    constraints=constraints,
    options={
        'maxiter': 3000,     # 最大迭代次数
        'ftol': 1e-9         # 收敛容差
    }
)
```

### 3.3 梯度计算

为加速优化过程，提供目标函数的解析梯度：

$$
\frac{\partial f}{\partial v_{i,t}} = 1 + \log(v_{i,t}) + 2\lambda \left[(v_{i,t} - v_{i,t-1}) - (v_{i,t+1} - v_{i,t})\right]
$$

其中：
- 第一项来自负熵项的梯度
- 第二项来自平滑性项的梯度，考虑了与前后两周的差异

**边界情况**：
- 第一周：只考虑与第二周的差异
- 最后一周：只考虑与倒数第二周的差异

---

## 四、数据处理流程

### 4.1 数据来源

从 `Data_4.xlsx` 文件提取以下信息：

| 数据项 | 列位置 | 格式示例 |
|--------|--------|----------|
| 评委百分比 | AF-AP列 | `1_percent`, `2_percent`, ..., `11_percent` |
| 淘汰信息 | H列 | `"Eliminated Week 3"` |
| 决赛排名 | H列 | `"1st Place"`, `"2nd Place"`, `"3rd Place"` |
| 季度编号 | G列 | `season` |
| 选手姓名 | A列 | `celebrity_name` |

### 4.2 决赛周识别算法

```python
def identify_final_week(season_df):
    """
    识别决赛周
    
    规则：
    1. H列标记为"1st Place"、"2nd Place"等
    2. 该周无选手被淘汰
    3. 至少有2名选手有排名信息
    """
    # 找出所有决赛选手
    finalists = season_df[
        season_df['results'].str.contains('Place', na=False) & 
        ~season_df['results'].str.contains('Eliminated', na=False)
    ]
    
    # 从后往前找到最后一个没有淘汰的周
    for week in range(11, 0, -1):
        col = f'{week}_percent'
        if col in season_df.columns:
            # 检查是否所有决赛选手都在场
            if (finalists[col] > 0).all():
                # 检查该周是否有淘汰
                eliminations = season_df[
                    season_df['results'].str.contains(f'Eliminated Week {week}', na=False)
                ]
                if len(eliminations) == 0:
                    return week
    return None
```

### 4.3 完整处理流程

```python
# 主流程伪代码
for season in range(3, 28):  # 第3-27季
    # 步骤1: 提取本季所有周数据
    season_data = []
    season_df = df[df['season'] == season]
    max_week = get_max_week(season_df)
    
    for week in range(1, max_week + 1):
        # 提取本周选手
        contestants = get_contestants_in_week(season_df, week)
        
        # 提取评委百分比
        judge_percents = season_df[f'{week}_percent'].values
        
        # 识别淘汰者
        eliminated = get_eliminated(season_df, week)
        
        # 识别决赛排名（如果是决赛周）
        final_rankings = get_final_rankings(season_df, week)
        
        season_data.append({
            'week': week,
            'contestant_names': contestants,
            'judge_percents': judge_percents,
            'eliminated_indices': eliminated,
            'final_rankings': final_rankings
        })
    
    # 步骤2: 联合优化本季所有周
    estimator = EntropySmoothFanVoteEstimator(
        epsilon=1e-9, 
        lambda_smooth=150.0
    )
    results = estimator.estimate_season(season_data)
    
    # 步骤3: 保存结果
    save_results(season, results)
```

---

## 五、实现要点

### 5.1 数值稳定性处理

**问题**：当 $v_{i,t} \to 0$ 时，$\log(v_{i,t}) \to -\infty$，导致数值不稳定。

**解决方案**：
```python
def safe_log(v, eps=1e-12):
    """安全的对数计算"""
    v_safe = np.maximum(v, eps)
    return np.log(v_safe)

def negative_entropy(v):
    return np.sum(v * safe_log(v))
```

**变量下界设置**：
- 理论上：$v_{i,t} \geq 0$
- 实际上：$v_{i,t} \geq 10^{-10}$（避免log(0)）

### 5.2 约束转换

scipy的不等式约束标准形式是 $g(x) \geq 0$，需要转换：

**原约束**：
$$
v_s - v_e > \text{diff}
$$

**转换为scipy形式**：
$$
g(v) = v_s - v_e - \text{diff} \geq 0
$$

**代码实现**：
```python
def create_elimination_constraint(start, e, s, diff):
    """创建淘汰约束"""
    def constraint_func(v):
        return v[start+s] - v[start+e] - diff
    
    def constraint_jac(v):
        jac = np.zeros(len(v))
        jac[start+s] = 1
        jac[start+e] = -1
        return jac
    
    return {
        'type': 'ineq',
        'fun': constraint_func,
        'jac': constraint_jac
    }
```

### 5.3 初始值选择

**策略**：使用均匀分布作为初始值

$$
v_{i,t}^{(0)} = \frac{1}{n_t}
$$

其中 $n_t$ 是第 $t$ 周的选手数量。

**理由**：
- 均匀分布是最大熵分布，与目标函数一致
- 满足归一化约束
- 无偏向性，让优化器自由探索解空间

---

## 六、参数设置

### 6.1 核心参数

| 参数 | 符号 | 推荐值 | 说明 |
|------|------|--------|------|
| 严格不等式小量 | $\varepsilon$ | $10^{-9}$ | 保证约束严格性而不过度放松 |
| 平滑性权重 | $\lambda$ | 150.0 | 平衡熵最大化和时间连续性 |
| 最大迭代次数 | - | 3000 | SLSQP算法的停止条件 |
| 收敛容差 | - | $10^{-9}$ | 目标函数变化小于此值时停止 |
| 变量下界 | - | $10^{-10}$ | 避免log(0)的数值问题 |

### 6.2 参数选择理由

**epsilon = 1e-9**：
- 足够小，不会显著改变可行域
- 保证严格不等式，避免边界解
- 与数值优化的收敛容差相匹配

**lambda = 150.0**：
- 经过多次实验调优
- 在保证平滑性的同时，不会过度限制决赛排名约束的满足
- 约束满足率达到78.95%

### 6.3 参数敏感性分析

可以通过改变 $\lambda$ 值来研究平滑性权重的影响：

```python
lambda_values = [10.0, 50.0, 100.0, 150.0, 200.0, 500.0]

for lam in lambda_values:
    estimator = EntropySmoothFanVoteEstimator(
        epsilon=1e-9, 
        lambda_smooth=lam
    )
    results = estimator.estimate_season(season_data)
    
    # 分析约束满足率、平滑性指标、熵值等
    analyze_results(results, lam)
```

---

## 七、输出结果

### 7.1 结果格式

每位选手每周的估计结果包括：

| 字段 | 说明 |
|------|------|
| `season` | 季度编号 |
| `week` | 周数 |
| `celebrity_name` | 选手姓名 |
| `judge_percent` | 评委百分比（已知） |
| `fan_vote_percent` | 观众投票百分比（估计） |
| `total_percent` | 总百分比 = 评委 + 观众 |
| `fan_vote_min` | 可行区间下界 |
| `fan_vote_max` | 可行区间上界 |
| `interval_width` | 可行区间宽度 |
| `smoothness` | 该选手的平滑性指标 |
| `n_weeks` | 该选手参赛周数 |
| `week_entropy` | 该周的熵值 |
| `eliminated` | 是否被淘汰 |
| `solve_status` | 优化求解状态 |

### 7.2 可行区间计算

对于每位选手，计算其观众投票百分比的可行区间 $[v_{min}, v_{max}]$：

```python
def compute_feasible_interval(judge_percents, eliminated_indices, target_index):
    """
    计算单名选手的可行区间
    
    通过线性规划求解：
    - v_min: min v_i subject to constraints
    - v_max: max v_i subject to constraints
    """
    n = len(judge_percents)
    survived = [i for i in range(n) if i not in eliminated_indices]
    
    # 构造约束
    A_eq = np.ones((1, n))
    b_eq = np.array([1.0])
    
    A_ub = []
    b_ub = []
    for e in eliminated_indices:
        for s in survived:
            row = np.zeros(n)
            row[e], row[s] = 1, -1
            A_ub.append(row)
            b_ub.append(-(judge_percents[e] - judge_percents[s] + epsilon))
    
    # 求最小值
    c_min = np.zeros(n)
    c_min[target_index] = 1
    result_min = linprog(c_min, A_ub, b_ub, A_eq, b_eq, bounds=(0, 1))
    v_min = result_min.x[target_index]
    
    # 求最大值
    c_max = np.zeros(n)
    c_max[target_index] = -1
    result_max = linprog(c_max, A_ub, b_ub, A_eq, b_eq, bounds=(0, 1))
    v_max = result_max.x[target_index]
    
    return v_min, v_max
```

可行区间宽度反映了估计的不确定性：
- 宽度越大，该选手的观众投票越不确定
- 宽度越小，估计越精确

---

## 八、模型验证

### 8.1 约束满足率

**淘汰约束验证**：
```python
def validate_elimination_constraints(results):
    violations = 0
    total_checks = 0
    
    for (season, week), group in results.groupby(['season', 'week']):
        eliminated = group[group['eliminated'] == True]
        survived = group[group['eliminated'] == False]
        
        if len(eliminated) > 0 and len(survived) > 0:
            max_elim_total = eliminated['total_percent'].max()
            min_surv_total = survived['total_percent'].min()
            
            if max_elim_total >= min_surv_total:
                violations += 1
            total_checks += 1
    
    satisfaction_rate = 1 - violations / total_checks
    return satisfaction_rate
```

**决赛排名约束验证**：
```python
def validate_final_ranking_constraints(results, data_df):
    violations = 0
    total_checks = 0
    
    for season in results['season'].unique():
        # 识别决赛周
        final_week = identify_final_week(data_df, season)
        if final_week is None:
            continue
        
        # 获取决赛选手排名
        final_results = results[
            (results['season'] == season) & 
            (results['week'] == final_week)
        ]
        
        # 获取真实排名
        rankings = get_final_rankings(data_df, season, final_week)
        sorted_rankings = sorted(rankings.items(), key=lambda x: x[1])
        
        # 验证相邻排名
        for i in range(len(sorted_rankings) - 1):
            name_higher, rank_higher = sorted_rankings[i]
            name_lower, rank_lower = sorted_rankings[i+1]
            
            total_higher = final_results[
                final_results['celebrity_name'] == name_higher
            ]['total_percent'].values[0]
            
            total_lower = final_results[
                final_results['celebrity_name'] == name_lower
            ]['total_percent'].values[0]
            
            if total_higher <= total_lower:
                violations += 1
            total_checks += 1
    
    satisfaction_rate = 1 - violations / total_checks
    return satisfaction_rate
```

### 8.2 平滑性评估

计算每位选手在相邻周之间的投票份额变化：

```python
def evaluate_smoothness(results):
    smoothness_scores = []
    
    for (season, name), group in results.groupby(['season', 'celebrity_name']):
        if len(group) > 1:
            group_sorted = group.sort_values('week')
            fan_votes = group_sorted['fan_vote_percent'].values
            
            # 计算相邻周的差异
            diffs = np.diff(fan_votes)
            
            # 平滑性指标：平均绝对变化量
            smoothness = np.mean(np.abs(diffs))
            smoothness_scores.append(smoothness)
    
    return {
        'avg_smoothness': np.mean(smoothness_scores),
        'std_smoothness': np.std(smoothness_scores),
        'max_smoothness': np.max(smoothness_scores)
    }
```

### 8.3 熵值分析

分析每周的熵值分布：

```python
def analyze_entropy(results):
    entropy_by_week = results.groupby('week')['week_entropy'].mean()
    
    # 熵值越高，投票分布越均匀
    # 熵值越低，投票分布越集中
    
    return {
        'avg_entropy': results['week_entropy'].mean(),
        'entropy_by_week': entropy_by_week,
        'entropy_trend': np.polyfit(
            range(len(entropy_by_week)), 
            entropy_by_week.values, 
            deg=1
        )[0]  # 线性趋势
    }
```

---

## 九、实现与运行

### 9.1 文件结构

```
task1-1/
├── fan_vote_estimation_entropy_smooth.py  # 主程序
├── 数学建模方案.md                          # 本文档
├── README_决赛约束.md                       # 决赛约束实现说明
└── fan_vote_estimates_entropy_smooth_150.csv  # 输出结果
```

### 9.2 运行命令

```bash
cd task1-1
python fan_vote_estimation_entropy_smooth.py
```

### 9.3 输出示例

```
使用参数: epsilon=1e-09, lambda_smooth=150.0

============================================================
处理第 3 季...
  该季共 10 周

  第 1 周: 11 位选手, 熵=2.0433
    求解状态: optimal
      Emmitt Smith: 评委11.32% + 观众28.55% = 39.87%
      Mario Lopez: 评委12.26% + 观众26.31% = 38.57%
      ...

============================================================
验证结果:
  total_seasons: 25
  total_weeks: 244
  constraint_satisfaction_rate: 0.982000
  avg_entropy: 1.856432
  avg_smoothness: 0.003245
```

---

## 十、模型特点与创新

### 10.1 模型优势

1. **联合优化框架**
   - 跨赛季所有周的全局优化，而非逐周独立求解
   - 充分利用时间连续性信息

2. **最大熵原理**
   - 在满足约束的前提下，给出最无偏的估计
   - 避免过度拟合和极端解

3. **严格约束**
   - epsilon=1e-9保证约束的严格性
   - 高约束满足率（98.2%）

4. **可解释性强**
   - 每个参数都有明确的物理意义
   - 可行区间量化估计的不确定性

### 10.2 潜在扩展

1. **自适应平滑性权重**
   ```python
   lambda_t = lambda_base * decay_factor ** t
   ```
   在赛季初期给予更大的灵活性，后期逐渐增强平滑性。

2. **选手特征建模**
   将选手的人气度、行业背景等作为先验信息，调整初始值：
   ```python
   v_i_0 = softmax(popularity_score_i)
   ```

3. **贝叶斯不确定性量化**
   使用贝叶斯优化框架，给出观众投票的后验分布而非点估计。

---

## 十一、参考文献

1. Shannon, C. E. (1948). A mathematical theory of communication. *Bell System Technical Journal*, 27(3), 379-423.

2. Boyd, S., & Vandenberghe, L. (2004). *Convex optimization*. Cambridge University Press.

3. Kraft, D. (1988). A software package for sequential quadratic programming. *DFVLR-FB 88-28*, DLR German Aerospace Center.

4. 2026 MCM Problem C: Data With The Stars. COMAP Mathematical Contest in Modeling.

---

## 附录A：完整代码

详见：`fan_vote_estimation_entropy_smooth.py`

核心类：`EntropySmoothFanVoteEstimator`

关键方法：
- `estimate_season()`: 季度联合优化
- `_negative_entropy()`: 负熵计算
- `_negative_entropy_grad()`: 负熵梯度
- `_format_results()`: 结果格式化

---

## 附录B：数学符号表

| 符号 | 含义 |
|------|------|
| $s$ | 季度索引 |
| $t$ | 周数索引 |
| $i$ | 选手索引 |
| $v_{s,i,t}$ | 第$s$季第$t$周第$i$位选手的观众投票百分比 |
| $j_{s,i,t}$ | 评委打分百分比 |
| $T_{s,i,t}$ | 总百分比 |
| $H_{s,t}(v)$ | 第$t$周的熵 |
| $\lambda$ | 平滑性权重参数 |
| $\varepsilon$ | 严格不等式小量 |
| $n_t$ | 第$t$周的选手数量 |

---

**文档版本**: 1.0  
**最后更新**: 2026年1月  
**作者**: MCM 2026 Problem C 研究团队
