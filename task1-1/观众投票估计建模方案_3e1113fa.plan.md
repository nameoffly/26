---
name: 观众投票估计建模方案
overview: 创建一份完整的数学建模文档，详细说明如何使用线性约束+规则化方法（最大熵+平滑性）估算第3-27季每位选手的观众投票百分比，包括数学公式推导、约束条件、求解算法和实现细节。
todos: []
isProject: false
---

# 观众投票估计数学建模与解法方案

## 一、问题描述

### 1.1 研究对象

- **数据范围**: 第3-27季 (使用百分比打分方法)
- **目标变量**: 每位选手在其参赛各周的观众投票百分比 $v_{i,t}$
- **已知数据**: 评委打分百分比 $j_{i,t}$、淘汰情况、决赛排名

### 1.2 计分规则

根据PDF文件第162-186行，第3-27季使用**百分比方法**:

- 评委百分比 = 选手评委总分 / 所有选手评委总分之和
- 观众百分比 = 选手观众票数 / 所有选手观众票数之和  
- **总百分比** = 评委百分比 + 观众百分比
- 总百分比最低的选手被淘汰（决赛周则用于排名）

## 二、数学模型

### 2.1 决策变量

对于第$s$季第$t$周的第$i$位选手，定义:

- $v_{s,i,t}$ : 观众投票百分比（待估计）
- $j_{s,i,t}$ : 评委打分百分比（已知，从Data_4.xlsx的AF-AP列提取）
- $T_{s,i,t} = j_{s,i,t} + v_{s,i,t}$ : 总百分比

### 2.2 优化目标函数

采用**最大熵原理**和**时间平滑性**的联合优化:

```
max  ∑_{s,t} H_{s,t}(v) - λ ∑_{s,t,i} (v_{s,i,t} - v_{s,i,t-1})²
```

等价于最小化:

```
min  ∑_{s,t} ∑_{i} v_{s,i,t} log(v_{s,i,t}) + λ ∑_{s,t,i} (v_{s,i,t} - v_{s,i,t-1})²
```

其中:

- 第一项: **负熵**，促使投票分布均匀，避免极端解
- 第二项: **平滑性惩罚**，确保同一选手的人气变化连续
- $λ ≥ 0$: 平滑性权重参数（建议值150.0）

### 2.3 线性约束条件

#### (1) 归一化约束

每周所有选手的观众投票百分比之和为1:

```
∑_i v_{s,i,t} = 1,  ∀s, t
```

#### (2) 非负性约束

```
v_{s,i,t} ≥ 0,  ∀s, i, t
```

#### (3) 非决赛周的淘汰约束

对于第$t$周被淘汰的选手$e$和幸存者$s$:

```
T_{s,e,t} < T_{s,s,t}
即: j_{s,e,t} + v_{s,e,t} < j_{s,s,t} + v_{s,s,t} + ε
转换为: v_{s,s,t} - v_{s,e,t} > j_{s,e,t} - j_{s,s,t} + ε
```

其中$ε > 0$是严格不等式的小量（建议使用1e-9，保证约束严格性）

**说明**: 

- 若不使用epsilon，直接用$≥$约束，优化器可能给出边界解（恰好相等）
- epsilon=1e-9足够小，既保证严格不等式，又不会过度放松约束
- 过大的epsilon（如0.01）会导致不合理的解空间

#### (4) 决赛周的排名约束

识别决赛周: H列（results）中标记为"1st Place"、"2nd Place"等且该周无淘汰

对于排名第$k$和第$k+1$的选手:

```
T_{rank_k} > T_{rank_k+1} + ε
即: j_{rank_k} + v_{rank_k} > j_{rank_k+1} + v_{rank_k+1} + ε
转换为: v_{rank_k} - v_{rank_k+1} > (j_{rank_k+1} - j_{rank_k}) + ε
```

## 三、求解方法

### 3.1 季度联合优化

对每个季度的所有周进行**联合优化**而非逐周求解，原因:

- 时间平滑性约束需要跨周信息
- 避免人气突变，保证结果合理性

### 3.2 优化算法

使用**序列二次规划(SLSQP)**方法:

```python
from scipy.optimize import minimize

# 构造目标函数
def objective(v):
    neg_entropy = ∑_t ∑_i v[i,t] * log(v[i,t])
    smoothness = λ * ∑_i ∑_t (v[i,t] - v[i,t-1])²
    return neg_entropy + smoothness

# 构造约束
constraints = [
    {'type': 'eq', 'fun': lambda v: ∑_i v[i,t] - 1},  # 归一化
    {'type': 'ineq', 'fun': lambda v: v[s] - v[e] - diff},  # 淘汰约束
    {'type': 'ineq', 'fun': lambda v: v[rank_k] - v[rank_k+1] - diff}  # 排名约束
]

# 求解
result = minimize(
    objective, 
    v0,  # 初始值（均匀分布）
    method='SLSQP',
    jac=objective_grad,  # 梯度
    bounds=[(1e-10, 1.0)],  # 变量界
    constraints=constraints
)
```

### 3.3 梯度计算

目标函数的梯度:

```
∂f/∂v_{i,t} = 1 + log(v_{i,t}) + 2λ[(v_{i,t} - v_{i,t-1}) - (v_{i,t+1} - v_{i,t})]
```

## 四、数据处理流程

### 4.1 数据提取

从[Data_4.xlsx](d:\Users\13016\Desktop\26MCM\2026_C\Data_4.xlsx)提取:

1. **评委百分比**: AF-AP列 (`1_percent` ~ `11_percent`)
2. **淘汰信息**: H列 (`results`)，格式如"Eliminated Week 3"
3. **决赛排名**: H列中的"1st Place"、"2nd Place"等
4. **决赛周识别**: 最大淘汰周数+1，或无淘汰且有排名标记的周

### 4.2 处理步骤

```python
# 伪代码
for season in range(3, 28):
    # 1. 提取本季所有周数据
    season_data = []
    for week in range(1, max_week+1):
        contestants = get_contestants_in_week(season, week)
        judge_percents = get_judge_percents(season, week)
        eliminated = get_eliminated(season, week)
        final_rankings = get_final_rankings(season, week)  # 如果是决赛周
        
        season_data.append({
            'week': week,
            'contestant_names': contestants,
            'judge_percents': judge_percents,
            'eliminated_indices': eliminated,
            'final_rankings': final_rankings
        })
    
    # 2. 联合优化本季所有周
    results = estimator.estimate_season(season_data)
    
    # 3. 保存结果
    save_results(results)
```

## 五、实现要点

### 5.1 数值稳定性

- 对数计算时添加小量: $v + ε_{小}$ (如1e-12)
- 变量下界设为小正数而非0，避免log(0)

### 5.2 约束处理

scipy的不等式约束是 $g(x) ≥ 0$ 形式，需转换:

```python
# 原约束: v_s - v_e >= diff
# scipy形式: -(v_s - v_e) + diff <= 0 转为 (v_s - v_e) - diff >= 0
constraints.append({
    'type': 'ineq',
    'fun': lambda v: v[s] - v[e] - diff
})
```

### 5.3 初始值选择

使用均匀分布作为初始值:

```
v_{i,t}^{(0)} = 1 / n_t
```

其中$n_t$是第$t$周的选手数

## 六、参数设置建议

基于现有代码[fan_vote_estimation_entropy_smooth.py](d:\Users\13016\Desktop\26MCM\2026_C\task1-1\fan_vote_estimation_entropy_smooth.py):

- **epsilon (ε)**: 1e-9 (严格不等式的小量，保证约束严格性而不过度放松)
- **lambda_smooth (λ)**: 150.0 (平滑性权重)
- **优化器**: SLSQP (序列二次规划)
- **最大迭代次数**: 3000
- **收敛容差**: 1e-9

**参数选择理由**:

- epsilon采用1e-9而非较大值（如0.01），避免约束过度松弛导致不合理解
- lambda=150.0在保证平滑性的同时，不会过度限制决赛排名约束的满足

## 七、输出结果

每位选手每周的估计结果包括:

1. 观众投票百分比 $v_{i,t}$
2. 总百分比 $T_{i,t} = j_{i,t} + v_{i,t}$
3. 可行区间 $[v_{min}, v_{max}]$
4. 平滑性指标
5. 每周熵值

## 八、模型验证

### 8.1 约束满足率

检查淘汰约束和决赛排名约束的满足情况

### 8.2 可行性分析

验证每周的解是否在可行域内

### 8.3 平滑性评估

计算相邻周投票份额的变化量

## 九、实现文件

完整实现见:

- 主程序: [fan_vote_estimation_entropy_smooth.py](d:\Users\13016\Desktop\26MCM\2026_C\task1-1\fan_vote_estimation_entropy_smooth.py)
- 数据文件: [Data_4.xlsx](d:\Users\13016\Desktop\26MCM\2026_C\Data_4.xlsx)

运行命令:

```bash
python fan_vote_estimation_entropy_smooth.py
```

输出文件:

```
fan_vote_estimates_entropy_smooth_150.csv
```

